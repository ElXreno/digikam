From 010d0293d322ce458d00ef1ff35ac90562ef7da6 Mon Sep 17 00:00:00 2001
From: Marcel Wiesweg <marcel.wiesweg@gmx.de>
Date: Tue, 4 Mar 2014 13:41:50 +0100
Subject: [PATCH 765/804] Reorder mutex locks - the ImageInfo ReadWriteLock
 must remain an "inner", transparent mutex. It is called from a place where
 DatabaseAccess is locked, so DatabaseAccess must not be locked from a place
 where the ImageInfo lock is held. To reduce by one or two mutex locks,
 consolidate read operations at one place and return the hash from a local
 variable which is in sync with the cached hash. (note: we do not rule out a
 parallel operation between the DatabaseAccess and the writing of the cached
 values. it's so far acceptable for a read cache.)

CCMAIL: mike@mghansen.de
BUG: 331578
---
 libs/database/imageinfo.cpp | 33 ++++++++++++++++++++++-----------
 1 file changed, 22 insertions(+), 11 deletions(-)

diff --git a/libs/database/imageinfo.cpp b/libs/database/imageinfo.cpp
index 631dda7..223ec13 100644
--- a/libs/database/imageinfo.cpp
+++ b/libs/database/imageinfo.cpp
@@ -1711,24 +1711,32 @@ QDebug& operator<<(QDebug& stream, const ImageInfo& info)
 
 ImageInfo::DatabaseFieldsHashRaw ImageInfo::getDatabaseFieldsRaw(const DatabaseFields::Set& requestedSet) const
 {
-    if (!m_data)
+    if (!m_data || (!m_data->hasVideoMetadata && !m_data->hasImageMetadata))
     {
         return DatabaseFieldsHashRaw();
     }
 
-    // keep the system locked to make sure all fields are taken from the same cache state
-    /// @todo Actually we need a read-write-lock, but we only have a write lock.
-    ImageInfoWriteLocker writeLocker;
+    DatabaseFields::VideoMetadataMinSizeType cachedVideoMetadata;
+    DatabaseFields::ImageMetadataMinSizeType cachedImageMetadata;
+    ImageInfo::DatabaseFieldsHashRaw cachedHash;
+    // consolidate to one ReadLocker. In particular, the shallow copy of the QHash must be done under protection
+    {
+        ImageInfoReadLocker lock;
+        cachedVideoMetadata = m_data->videoMetadataCached;
+        cachedImageMetadata = m_data->imageMetadataCached;
+        cachedHash = m_data->databaseFieldsHashRaw;
+    }
+
     if (requestedSet.hasFieldsFromVideoMetadata() && m_data->hasVideoMetadata)
     {
         const DatabaseFields::VideoMetadata requestedVideoMetadata = requestedSet.getVideoMetadata();
+        const DatabaseFields::VideoMetadata missingVideoMetadata = requestedVideoMetadata & ~cachedVideoMetadata;
 
-        const DatabaseFields::VideoMetadata missingVideoMetadata = requestedVideoMetadata & ~m_data->videoMetadataCached;
-//         kDebug()<<QString("videometadata: requested: %1 missing: %3").arg(requestedVideoMetadata, 0, 16).arg(missingVideoMetadata, 0, 16);
         if (missingVideoMetadata)
         {
             const QVariantList fieldValues = DatabaseAccess().db()->getVideoMetadata(m_data->id, missingVideoMetadata);
 
+            ImageInfoWriteLocker lock;
             if (fieldValues.isEmpty())
             {
                 m_data.constCastData()->hasVideoMetadata = false;
@@ -1746,21 +1754,23 @@ ImageInfo::DatabaseFieldsHashRaw ImageInfo::getDatabaseFieldsRaw(const DatabaseF
                     m_data.constCastData()->databaseFieldsHashRaw.insertField(*it, fieldValue);
                 }
 
-                m_data.constCastData()->videoMetadataCached|=missingVideoMetadata;
+                m_data.constCastData()->videoMetadataCached |= missingVideoMetadata;
             }
+            // update for return value
+            cachedHash = m_data->databaseFieldsHashRaw;
         }
     }
 
     if (requestedSet.hasFieldsFromImageMetadata() && m_data->hasImageMetadata)
     {
         const DatabaseFields::ImageMetadata requestedImageMetadata = requestedSet.getImageMetadata();
+        const DatabaseFields::ImageMetadata missingImageMetadata   = requestedImageMetadata & ~cachedImageMetadata;
 
-        const DatabaseFields::ImageMetadata missingImageMetadata = requestedImageMetadata & ~m_data->imageMetadataCached;
-//         kDebug()<<QString("imagemetadata: requested: %1 missing: %3").arg(requestedImageMetadata, 0, 16).arg(missingImageMetadata, 0, 16);
         if (missingImageMetadata)
         {
             const QVariantList fieldValues = DatabaseAccess().db()->getImageMetadata(m_data->id, missingImageMetadata);
 
+            ImageInfoWriteLocker lock;
             if (fieldValues.isEmpty())
             {
                 m_data.constCastData()->hasImageMetadata = false;
@@ -1778,13 +1788,14 @@ ImageInfo::DatabaseFieldsHashRaw ImageInfo::getDatabaseFieldsRaw(const DatabaseF
                     m_data.constCastData()->databaseFieldsHashRaw.insertField(*it, fieldValue);
                 }
 
-                m_data.constCastData()->imageMetadataCached|=missingImageMetadata;
+                m_data.constCastData()->imageMetadataCached |= missingImageMetadata;
             }
+            cachedHash = m_data->databaseFieldsHashRaw;
         }
     }
 
     // We always return all fields, the caller can just retrieve the ones he needs.
-    return m_data->databaseFieldsHashRaw;
+    return cachedHash;
 }
 
 QVariant ImageInfo::getDatabaseFieldRaw(const DatabaseFields::Set& requestedField) const
-- 
1.9.0

